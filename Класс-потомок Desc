#include <iostream>
#include <string>
#include <memory>

using namespace std;

class Base {
public:
    Base() {
        cout << "[Base] Конструктор Base()" << endl;
    }

    Base(Base* obj) {
        cout << "[Base] Конструктор Base(Base*)" << endl;
    }

    Base(Base& obj) {
        cout << "[Base] Конструктор Base(Base&)" << endl;
    }

    virtual ~Base() {
        cout << "[Base] Деструктор ~Base()" << endl;
    }

    virtual void draw() {
        cout << "[Base] draw()" << endl;
    }

    virtual string classname() const { return "Base"; }
    
    virtual bool isA(const string& className) const { 
        return className == "Base"; 
    }
};

// ========== НОВЫЙ КОД ==========
class Desc : public Base {
public:
    // Конструкторы
    Desc() {
        cout << "[Desc] Конструктор Desc()" << endl;
    }

    Desc(Desc* obj) {
        cout << "[Desc] Конструктор Desc(Desc*)" << endl;
    }

    Desc(Desc& obj) {
        cout << "[Desc] Конструктор Desc(Desc&)" << endl;
    }

    // Деструктор
    ~Desc() override {
        cout << "[Desc] Деструктор ~Desc()" << endl;
    }

    // Переопределение метода
    void draw() override {
        cout << "[Desc] draw() - переопределение" << endl;
    }

    // Методы проверки класса
    string classname() const override { return "Desc"; }
    
    bool isA(const string& className) const override { 
        return className == "Desc" || Base::isA(className); 
    }
};
// ========== КОНЕЦ НОВОГО КОДА ==========
